<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>XmlStarlet Command Line XML Toolkit User's Guide</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077165757728"></a>XmlStarlet Command Line XML Toolkit User's Guide</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Mikhail</span> <span class="surname">Grushinskiy</span></h3></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#idm47077139742192">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm47077139729008">1. About XmlStarlet</a></span></dt><dt><span class="sect1"><a href="#idm47077139720112">2. Main Features</a></span></dt><dt><span class="sect1"><a href="#idm47077139705936">3. Supported Platforms</a></span></dt><dt><span class="sect1"><a href="#idm47077139695840">4. Finding binary packages</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm47077139681232">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm47077139680240">1. Installation on Linux</a></span></dt><dt><span class="sect1"><a href="#idm47077139676656">2. Installation on Solaris</a></span></dt><dt><span class="sect1"><a href="#idm47077139674848">3. Installation on MacOS X</a></span></dt><dt><span class="sect1"><a href="#idm47077139672672">4. Installation on Windows</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm47077139670224">3. Getting Started</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm47077139669232">1. Basic Command-Line Options</a></span></dt><dt><span class="sect1"><a href="#idm47077139665568">2. Studying Structure of XML Document</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm47077139653312">4. XmlStarlet Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm47077139652416">1. Querying XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139602800">2. Transforming XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139594320">3. Editing XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139576400">4. Validating XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139569312">5. Formatting XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139560880">6. Canonicalization of XML documents</a></span></dt><dt><span class="sect1"><a href="#idm47077139550832">7. XML and PYX format</a></span></dt><dt><span class="sect1"><a href="#idm47077139540960">8. Escape/Unescape special XML characters</a></span></dt><dt><span class="sect1"><a href="#idm47077139535968">9. List directory as XML</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm47077139531936">5. Common problems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm47077139530992">1. Namespaces and default namespace</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm47077139529952">1.1. The Problem: Why does nothing match?</a></span></dt><dt><span class="sect2"><a href="#idm47077139525808">1.2. The Solution</a></span></dt><dt><span class="sect2"><a href="#idm47077139523728">1.3. A More Convenient Solution</a></span></dt><dt><span class="sect2"><a href="#idm47077139518336">1.4. Deleting namespace declarations </a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm47077139514640">2. Special characters</a></span></dt><dt><span class="sect1"><a href="#idm47077139508800">3. Sorting</a></span></dt><dt><span class="sect1"><a href="#idm47077139504512">4. Validation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm47077139502176">6. Other XmlStarlet Resources</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139742192"></a>Chapter 1. Introduction</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139729008"></a>1. About XmlStarlet</h2></div></div></div><p><a class="link" href="http://xmlstar.sourceforge.net/" target="_top">XMLStarlet</a> is
      a set of command line utilities (tools) which can be used to transform,
      query, validate, and edit XML documents and files using simple set of
      shell commands in similar way it is done for plain text files using UNIX
      grep, sed, awk, diff, patch, join, etc commands.</p><p>This set of command line utilities can be used by those who deal
      with many XML documents on UNIX shell command prompt as well as for
      automated XML processing with shell scripts.</p><p>XMLStarlet command line utility is written in C and uses libxml2
      and libxslt from <a class="link" href="http://xmlsoft.org/" target="_top">http://xmlsoft.org/</a>. Implementation of
      extensive choice of options for XMLStarlet utility was only possible
      because of rich feature set of libxml2 and libxslt (many thanks to the
      developers of those libraries for great work).</p><p>'diff' and 'patch' options are not currently implemented. Other
      features need some work too. Please, send an email to the project
      administrator (see <a class="link" href="http://sourceforge.net/projects/xmlstar/" target="_top">http://sourceforge.net/projects/xmlstar/</a>)
      if you wish to help.</p><p>XMLStarlet is linked statically to both libxml2 and libxslt, so
      generally all you need to process XML documents is one executable file.
      To run XmlStarlet utility you can simple type 'xml' on command line and
      see list of options available.</p><p>XMLStarlet is open source freeware under MIT license which allows
      free use and distribution for both commercial and non-commercial
      projects.</p><p>We welcome any user's feedback on this project which would greatly
      help us to improve its quality. Comments, suggestions, feature requests,
      bug reports can be done via SourceForge project web site (see <a class="link" href="http://sourceforge.net/p/xmlstar/discussion/" target="_top">XMLStarlet
      Sourceforge forums</a>, or <a class="link" href="http://sourceforge.net/p/xmlstar/mailman/" target="_top">XMLStarlet
      mailing list</a>)</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139720112"></a>2. Main Features</h2></div></div></div><p>The toolkit's feature set includes options to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Check or validate XML files (simple well-formedness check,
          DTD, XSD, RelaxNG)</p></li><li class="listitem"><p>Calculate values of XPath expressions on XML files (such as
          running sums, etc)</p></li><li class="listitem"><p>Search XML files for matches to given XPath expressions</p></li><li class="listitem"><p>Apply XSLT stylesheets to XML documents (including EXSLT
          support, and passing parameters to stylesheets)</p></li><li class="listitem"><p>Query XML documents (ex. query for value of some elements of
          attributes, sorting, etc)</p></li><li class="listitem"><p>Modify or edit XML documents (ex. delete some elements)</p></li><li class="listitem"><p>Format or "beautify" XML documents (as changing indentation,
          etc)</p></li><li class="listitem"><p>Fetch XML documents using http:// or ftp:// URLs</p></li><li class="listitem"><p>Browse tree structure of XML documents (in similar way to 'ls'
          command for directories)</p></li><li class="listitem"><p>Include one XML document into another using XInclude</p></li><li class="listitem"><p>XML c14n canonicalization</p></li><li class="listitem"><p>Escape/unescape special XML characters in input text</p></li><li class="listitem"><p>Print directory as XML document</p></li><li class="listitem"><p>Convert XML into PYX format (based on ESIS - ISO 8879), and
          vice versa</p></li></ul></div><p></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139705936"></a>3. Supported Platforms</h2></div></div></div><p>Here is a list of platforms on which XmlStarlet is known to
      work.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Linux</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Solaris</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Windows</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>MacOS X</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>FreeBSD/NetBSD</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>HP-UX</p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>AIX</p></li></ul></div><p>You might be able to compile and make it on others too.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139695840"></a>4. Finding binary packages</h2></div></div></div><p>Here is a list of sites where you can also find XmlStarlet binary
      packages.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.suse.com/us/private/products/suse_linux/prof/packages_professional/xmlstarlet.html" target="_top">SuSE
          Packages</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://linux01.gwdg.de/~pbleser/rpm-navigation.php?cat=%2FUtilities%2Fxmlstarlet/" target="_top">SuSE
          Guru's RPM Site</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.freebsd.org/cgi/ports.cgi?query=xmlstarlet&amp;stype=all" target="_top">FreeBSD
          Ports</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.freshports.org/textproc/xmlstarlet/" target="_top">FreeBSD Fresh
          Ports</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://fink.sourceforge.net/pdb/package.php/xmlstarlet" target="_top">Mac OS
          Fink</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://rpms.mandrakeclub.com/linux/rpm2html/search.php?query=xmlstarlet" target="_top">Mandrake
          RPMs</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://gentoo-portage.com/app-text/xmlstarlet" target="_top">Gentoo
          Portage</a></p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://packages.debian.org/stable/text/xmlstarlet" target="_top">Debian</a></p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139681232"></a>Chapter 2. Installation</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139680240"></a>1. Installation on Linux</h2></div></div></div><p>Execute the following command as root</p><pre class="programlisting">rpm -i xmlstarlet-x.x.x-1.i386.rpm</pre><p>where x.x.x indicates package version.</p><p>You can use <a class="link" href="http://fr2.rpmfind.net/linux/rpm2html/search.php?query=xmlstarlet&amp;system=&amp;arch=" target="_top">http://rpmfind.net</a>
      to search for RPM appropriate for your distribution.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139676656"></a>2. Installation on Solaris</h2></div></div></div><p>Execute the following commands as root</p><pre class="programlisting">gunzip xmlstarlet-x.x.x-sol8-sparc-local.gz
pkgadd -d xmlstarlet-x.x.x-sol8-sparc-local all</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139674848"></a>3. Installation on MacOS X</h2></div></div></div><p>XmlStarlet is available on MacOS in Fink. <a class="link" href="http://fink.sourceforge.net/pdb/package.php/xmlstarlet" target="_top">See
      fink.sourceforge.net</a></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139672672"></a>4. Installation on Windows</h2></div></div></div><p>Unzip the file xmlstarlet-x.x.x-win32.zip to some directory. To
      take advantage of UNIX shell scripting you might want to run XmlStarlet
      from Cygwin. Consider installing <a class="link" href="http://www.cygwin.com/" target="_top">Cygwin</a> on your Windows
      machine.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139670224"></a>Chapter 3. Getting Started</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139669232"></a>1. Basic Command-Line Options</h2></div></div></div><p>Basic command line syntax: </p><pre class="programlisting">bash-2.03$ xml
XMLStarlet Toolkit: Command line utilities for XML
Usage: xml [&lt;options&gt;] &lt;command&gt; [&lt;cmd-options&gt;]
where &lt;command&gt; is one of:
   ed    (or edit)      - Edit/Update XML document(s)
   sel   (or select)    - Select data or query XML document(s) (XPATH, etc)
   tr    (or transform) - Transform XML document(s) using XSLT
   val   (or validate)  - Validate XML document(s) (well-formed/DTD/XSD/RelaxNG)
   fo    (or format)    - Format XML document(s)
   el    (or elements)  - Display element structure of XML document
   c14n  (or canonic)   - XML canonicalization
   ls    (or list)      - List directory as XML
   esc   (or escape)    - Escape special XML characters
   unesc (or unescape)  - Unescape special XML characters
   pyx   (or xmln)      - Convert XML into PYX format (based on ESIS - ISO 8879)
   p2x   (or depyx)     - Convert PYX into XML
&lt;options&gt; are:
   -q or --quiet        - no error output
   --doc-namespace      - extract namespace bindings from input doc (default)
   --no-doc-namespace   - don't extract namespace bindings from input doc
   --version            - show version
   --help               - show help
Wherever file name mentioned in command help it is assumed
that URL can be used instead as well.

Type: xml &lt;command&gt; --help &lt;ENTER&gt; for command help

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139665568"></a>2. Studying Structure of XML Document</h2></div></div></div><p>Before you do anything with your XML document you probably would
      like to know its structure at first. 'el' option could be used for this
      purpose.</p><p>Let's say you have the following XML document (table.xml)</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;</pre><pre class="programlisting">xml el table.xml</pre><p>would produce the following output.</p><pre class="programlisting">xml
xml/table
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField</pre><p>Every line in this output is an XPath expression which indicates a
      'path' to elements in XML document. You would use these XPath
      expressions to navigate through your XML documents in other XmlStarlet
      options.</p><p>XML documents can be pretty large but with a very simple
      structure. (This is espesially true for data driven XML documents ex:
      XML formatted result of select from SQL table). If you just interested
      in structure but not order of the elements you can use -u switch
      combined with 'el' option.</p><p>EXAMPLE:</p><pre class="programlisting">xml el -u table.xml</pre><p>Output:</p><pre class="programlisting">xml
xml/table
xml/table/rec
xml/table/rec/numField
xml/table/rec/stringField</pre><p>If you are interested not just in elements of your XML document,
      but you want to see attributes as well you can use -a switch with 'el'
      option. And every line of the output will still be a valid XPath
      expression.</p><p>EXAMPLE:</p><pre class="programlisting">xml el -a table.xml</pre><p>Output:</p><pre class="programlisting">xml
xml/table
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec
xml/table/rec/@id
xml/table/rec/numField
xml/table/rec/stringField</pre><p>If you are looking for attribute values as well use -v switch of
      'el' option. And again - every line of output is a valid XPath
      expression.</p><p>EXAMPLE:</p><pre class="programlisting">xml el -v table.xml</pre><p>Output:</p><pre class="programlisting">xml
xml/table
xml/table/rec[@id='1']
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec[@id='2']
xml/table/rec/numField
xml/table/rec/stringField
xml/table/rec[@id='3']
xml/table/rec/numField
xml/table/rec/stringField</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139653312"></a>Chapter 4. XmlStarlet Reference</h1></div></div></div><p></p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139652416"></a>1. Querying XML documents</h2></div></div></div><p>XmlStarlet 'select' or 'sel' option can be used to query or search
      XML documents. Here is synopsis for 'xml sel' command:</p><pre class="programlisting">XMLStarlet Toolkit: Select from XML document(s)
Usage: xml sel &lt;global-options&gt; {&lt;template&gt;} [ &lt;xml-file&gt; ... ]
where
  &lt;global-options&gt; - global options for selecting
  &lt;xml-file&gt; - input XML document file name/uri (stdin is used if missing)
  &lt;template&gt; - template for querying XML document with following syntax:

&lt;global-options&gt; are:
  -Q or --quiet             - do not write anything to standard output.
  -C or --comp              - display generated XSLT
  -R or --root              - print root element &lt;xsl-select&gt;
  -T or --text              - output is text (default is XML)
  -I or --indent            - indent output
  -D or --xml-decl          - do not omit xml declaration line
  -B or --noblanks          - remove insignificant spaces from XML tree
  -E or --encode &lt;encoding&gt; - output in the given encoding (utf-8, unicode...)
  -N &lt;name&gt;=&lt;value&gt;         - predefine namespaces (name without 'xmlns:')
                              ex: xsql=urn:oracle-xsql
                              Multiple -N options are allowed.
  --net                     - allow fetch DTDs or entities over network
  --help                    - display help

Syntax for templates: -t|--template &lt;options&gt;
where &lt;options&gt;
  -c or --copy-of &lt;xpath&gt;   - print copy of XPATH expression
  -v or --value-of &lt;xpath&gt;  - print value of XPATH expression
  -o or --output &lt;string&gt;   - output string literal
  -n or --nl                - print new line
  -f or --inp-name          - print input file name (or URL)
  -m or --match &lt;xpath&gt;     - match XPATH expression
  --var &lt;name&gt; &lt;value&gt; --break or
  --var &lt;name&gt;=&lt;value&gt;      - declare a variable (referenced by $name)
  -i or --if &lt;test-xpath&gt;   - check condition &lt;xsl:if test="test-xpath"&gt;
  --elif &lt;test-xpath&gt;       - check condition if previous conditions failed
  --else                    - check if previous conditions failed
  -e or --elem &lt;name&gt;       - print out element &lt;xsl:element name="name"&gt;
  -a or --attr &lt;name&gt;       - add attribute &lt;xsl:attribute name="name"&gt;
  -b or --break             - break nesting
  -s or --sort op xpath     - sort in order (used after -m) where
  op is X:Y:Z, 
      X is A - for order="ascending"
      X is D - for order="descending"
      Y is N - for data-type="numeric"
      Y is T - for data-type="text"
      Z is U - for case-order="upper-first"
      Z is L - for case-order="lower-first"

There can be multiple --match, --copy-of, --value-of, etc options
in a single template. The effect of applying command line templates
can be illustrated with the following XSLT analogue

xml sel -t -c "xpath0" -m "xpath1" -m "xpath2" -v "xpath3" \
        -t -m "xpath4" -c "xpath5"

is equivalent to applying the following XSLT

&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
  &lt;xsl:call-template name="t2"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:copy-of select="xpath0"/&gt;
  &lt;xsl:for-each select="xpath1"&gt;
    &lt;xsl:for-each select="xpath2"&gt;
      &lt;xsl:value-of select="xpath3"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t2"&gt;
  &lt;xsl:for-each select="xpath4"&gt;
    &lt;xsl:copy-of select="xpath5"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;

</pre><p>'select' option allows you basically avoid writting XSLT
      stylesheet to perform some queries on XML documents. I.e. various
      combinations of command line parameters will let you to generate XSLT
      stylesheet and apply in to XML documents with a single command line.
      Very often you do not really care what XSLT was created for you 'select'
      command, but in those cases when you do; you can always use -C or --comp
      switch which will let you see exactly which XSLT is applied to your
      input.</p><p>'select' option supports many EXSLT functions in XPath
      expressions.</p><p>Here are few examples which will help to understand how 'xml
      select' works:</p><p>EXAMPLE:</p><p>Count elements matching XPath expression:</p><p></p><pre class="programlisting">xml sel -t -v "count(/xml/table/rec/numField)" table.xml</pre><p>Input (table.xml):</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;</pre><p>Output:</p><pre class="programlisting">3
</pre><p>Let's take a close look what it did internally. For that we will
      use '-C' option</p><pre class="programlisting">$ xml sel -C -t -v "count(/xml/table/rec/numField)"
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:exslt="http://exslt.org/common"
 xmlns:math="http://exslt.org/math"
 xmlns:date="http://exslt.org/dates-and-times"
 xmlns:func="http://exslt.org/functions"
 xmlns:set="http://exslt.org/sets"
 xmlns:str="http://exslt.org/strings"
 xmlns:dyn="http://exslt.org/dynamic"
 xmlns:saxon="http://icl.com/saxon"
 xmlns:xalanredirect="org.apache.xalan.xslt.extensions.Redirect"
 xmlns:xt="http://www.jclark.com/xt"
 xmlns:libxslt="http://xmlsoft.org/XSLT/namespace"
 xmlns:test="http://xmlsoft.org/XSLT/"
 extension-element-prefixes=
   "exslt math date func set str dyn saxon xalanredirect xt libxslt test"
 exclude-result-prefixes="math str"&gt;
&lt;xsl:output omit-xml-declaration="yes" indent="no"/&gt;
&lt;xsl:param name="inputFile"&gt;-&lt;/xsl:param&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:value-of select="count(/xml/table/rec/numField)"/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p>Ignoring some XSLT stuff to make it brief:</p><pre class="programlisting">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output omit-xml-declaration="yes" indent="no"/&gt;
&lt;xsl:param name="inputFile"&gt;-&lt;/xsl:param&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:value-of select="count(/xml/table/rec/numField)"/&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p>Every -t option is mapped into XSLT template. Options after '-t'
      are mapped into XSLT elements:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>-v to &lt;xsl:value-of&gt;</p></li><li class="listitem"><p>-c to &lt;xsl:copy-of&gt;</p></li><li class="listitem"><p>-e to &lt;xsl:element&gt;</p></li><li class="listitem"><p>-a to &lt;xsl:attribute&gt;</p></li><li class="listitem"><p>-s to &lt;xsl:sort&gt;</p></li><li class="listitem"><p>-m to &lt;xsl:for-each&gt;</p></li><li class="listitem"><p>-i to &lt;xsl:if&gt;</p></li><li class="listitem"><p>and so on</p></li></ul></div><p>By default subsequent options (for instance: -m) will result in
      nested corresponding XSLT elements (&lt;xsl:for-each&gt; for '-m'). To
      break this nesting you would have to put '-b' or '--break' after first
      '-m'.</p><p>Below are few more examples:</p><p>EXAMPLE</p><p>Count all nodes in XML documents. Print input name and node count
      after it.</p><pre class="programlisting">xml sel -t -f -o " " -v "count(//node())" xml/table.xml xml/tab-obj.xml</pre><p>Output:</p><pre class="programlisting">xml/table.xml 32
xml/tab-obj.xml 41</pre><p></p><p>EXAMPLE</p><p>Find XML files matching XPath expression (containing 'object'
      element)</p><pre class="programlisting">xml sel -t -m //object -f xml/table.xml xml/tab-obj.xml</pre><p>Result output:</p><pre class="programlisting">xml/tab-obj.xml</pre><p></p><p>EXAMPLE</p><p>Calculate EXSLT (XSLT extentions) XPath value</p><pre class="programlisting">echo "&lt;x/&gt;" | xml sel -t -v "math:abs(-1000)"</pre><p>Result output:</p><pre class="programlisting">1000</pre><p></p><p>EXAMPLE</p><p>Adding elements and attributes using command line 'xml sel'</p><pre class="programlisting">echo "&lt;x/&gt;" | xml sel -t -m / -e xml -e child -a data -o value</pre><p>Result Output:</p><pre class="programlisting">&lt;xml&gt;&lt;child data="value"/&gt;&lt;/xml&gt;</pre><p></p><p>EXAMPLE</p><p>Query XML document and produce sorted text table</p><pre class="programlisting">xml sel -T -t -m /xml/table/rec -s D:N:- "@id" \
  -v "concat(@id,'|',numField,'|',stringField)" -n xml/table.xml</pre><p>Result Output:</p><pre class="programlisting">3|-23|stringValue
2|346|Text Value
1|123|String Value</pre><p>Equivalent stylesheet</p><pre class="programlisting">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output omit-xml-declaration="yes" indent="no" method="text"/&gt;
&lt;xsl:param name="inputFile"&gt;-&lt;/xsl:param&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:for-each select="/xml/table/rec"&gt;
    &lt;xsl:sort order="descending" data-type="number" 
      case-order="upper-first" select="@id"/&gt;
    &lt;xsl:value-of select="concat(@id,'|',numField,'|',stringField)"/&gt;
    &lt;xsl:value-of select="'&amp;#10;'"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p></p><p>EXAMPLE</p><p>Predefine namespaces for XPath expressions</p><pre class="programlisting">xml sel -N xsql=urn:oracle-xsql -t -v /xsql:query xsql/jobserve.xsql</pre><p>Input (xsql/jobserve.xsql)</p><pre class="programlisting">$ cat xsql/jobserve.xsql
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="jobserve.xsl"?&gt;
&lt;xsql:query connection="jobs" xmlns:xsql="urn:oracle-xsql" max-rows="5"&gt;
  SELECT substr(title,1,26) short_title, title, location, skills
  FROM job
  WHERE UPPER(title) LIKE '%ORACLE%'
  ORDER BY first_posted DESC
&lt;/xsql:query&gt;</pre><p>Result output</p><pre class="programlisting">  SELECT substr(title,1,26) short_title, title, location, skills
  FROM job
  WHERE UPPER(title) LIKE '%ORACLE%'
  ORDER BY first_posted DESC
</pre><p></p><p>EXAMPLE</p><p>Print structure of XML element using xml sel (advanced XPath
      expressions and xml sel command usage)</p><pre class="programlisting">xml sel -T -t -m '//*' \
-m 'ancestor-or-self::*' -v 'name()' -i 'not(position()=last())' -o . -b -b -n \
xml/structure.xml</pre><p>Input (xml/structure.xml)</p><pre class="programlisting">&lt;a1&gt;
  &lt;a11&gt;
    &lt;a111&gt;
      &lt;a1111/&gt;
    &lt;/a111&gt;
    &lt;a112&gt;
      &lt;a1121/&gt;
    &lt;/a112&gt;
  &lt;/a11&gt;
  &lt;a12/&gt;
  &lt;a13&gt;
    &lt;a131/&gt;
  &lt;/a13&gt;
&lt;/a1&gt;</pre><p>Result Output:</p><pre class="programlisting">a1
a1.a11
a1.a11.a111
a1.a11.a111.a1111
a1.a11.a112
a1.a11.a112.a1121
a1.a12
a1.a13
a1.a13.a131</pre><p>This example is a good demonstration of nesting control. Here is
      corresponding XSLT:</p><pre class="programlisting">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output omit-xml-declaration="yes" indent="no" method="text"/&gt;
&lt;xsl:param name="inputFile"&gt;-&lt;/xsl:param&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:for-each select="//*"&gt;
    &lt;xsl:for-each select="ancestor-or-self::*"&gt;
      &lt;xsl:value-of select="name()"/&gt;
      &lt;xsl:if test="not(position()=last())"&gt;
        &lt;xsl:value-of select="'.'"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="'&amp;#10;'"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p></p><p></p><p>EXAMPLE</p><p>Print all links of xhtml document</p><pre class="programlisting">xml sel --net --html -T -t -m "//*[local-name()='a']" \
   -o 'NAME: ' -v "translate(. , '&amp;#10;', ' ')" -n \
   -o 'LINK: ' -v @href -n -n \
   http://xmlstar.sourceforge.net/</pre><p>Sample output</p><pre class="programlisting">NAME: XmlStarlet SourceForge Site
LINK: http://sourceforge.net/projects/xmlstar/

NAME: XmlStarlet CVS Source
LINK: http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/xmlstar/

NAME: XmlStarlet on Freshmeat.Net
LINK: http://freshmeat.net/projects/xmlstarlet/

NAME: XMLStarlet Sourceforge forums
LINK: http://sourceforge.net/forum/?group_id=66612

NAME: XMLStarlet mailing list
LINK: http://lists.sourceforge.net/lists/listinfo/xmlstar-devel
</pre><p></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139602800"></a>2. Transforming XML documents</h2></div></div></div><p>Here is synopsis for 'xml tr' command:</p><pre class="programlisting">XMLStarlet Toolkit: Transform XML document(s) using XSLT
Usage: xml tr [&lt;options&gt;] &lt;xsl-file&gt; {-p|-s &lt;name&gt;=&lt;value&gt;} [ &lt;xml-file-or-uri&gt; ... ]
where
   &lt;xsl-file&gt;      - main XSLT stylesheet for transformation
   &lt;xml-file&gt;      - input XML document file name (stdin is used if missing)
   &lt;name&gt;=&lt;value&gt;  - name and value of the parameter passed to XSLT processor
   -p              - parameter is XPATH expression ("'string'" to quote string)
   -s              - parameter is a string literal
&lt;options&gt; are:
   --omit-decl     - omit xml declaration &lt;?xml version="1.0"?&gt;
   --show-ext      - show list of extensions
   --val           - allow validate against DTDs or schemas
   --net           - allow fetch DTDs or entities over network
   --xinclude      - do XInclude processing on document input
   --maxdepth val  - increase the maximum depth
   --html          - input document(s) is(are) in HTML format
   --catalogs      - use SGML catalogs from $SGML_CATALOG_FILES
                     otherwise XML catalogs starting from
                     file:///etc/xml/catalog are activated by default

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)

Current implementation uses libxslt from GNOME codebase as XSLT processor
(see http://xmlsoft.org/ for more details)
</pre><p>EXAMPLE:</p><pre class="programlisting"># Transform passing parameters to XSLT stylesheet
xml tr xsl/param1.xsl -p Count='count(/xml/table/rec)' -s Text="Count=" xml/table.xml
</pre><p>Input xsl/params1.xsl</p><pre class="programlisting">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="text"/&gt;
&lt;xsl:param name="Text"/&gt;
&lt;xsl:param name="Count"/&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:for-each select="/xml"&gt;
    &lt;xsl:value-of select="$Text"/&gt;
    &lt;xsl:value-of select="$Count"/&gt;
    &lt;xsl:value-of select="'&amp;#10;'"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre><p>Output</p><pre class="programlisting">Count=3
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139594320"></a>3. Editing XML documents</h2></div></div></div><p>Here is the synopsis for 'xml ed' command:</p><pre class="programlisting">XMLStarlet Toolkit: Edit XML document(s)
Usage: xml ed &lt;global-options&gt; {&lt;action&gt;} [ &lt;xml-file-or-uri&gt; ... ]
where
  &lt;global-options&gt;  - global options for editing
  &lt;xml-file-or-uri&gt; - input XML document file name/uri (stdin is used if missing)

&lt;global-options&gt; are:
  -P (or --pf)        - preserve original formatting
  -S (or --ps)        - preserve non-significant spaces
  -O (or --omit-decl) - omit XML declaration (&lt;?xml ...?&gt;)
  -N &lt;name&gt;=&lt;value&gt;   - predefine namespaces (name without 'xmlns:')
                        ex: xsql=urn:oracle-xsql
                        Multiple -N options are allowed.
                        -N options must be last global options.
  --help or -h        - display help

where &lt;action&gt;
   -d or --delete &lt;xpath&gt;
   -i or --insert &lt;xpath&gt; -t (--type) elem|text|attr -n &lt;name&gt; -v (--value) &lt;value&gt;
   -a or --append &lt;xpath&gt; -t (--type) elem|text|attr -n &lt;name&gt; -v (--value) &lt;value&gt;
   -s or --subnode &lt;xpath&gt; -t (--type) elem|text|attr -n &lt;name&gt; -v (--value) &lt;value&gt;
   -m or --move &lt;xpath1&gt; &lt;xpath2&gt;
   -r or --rename &lt;xpath1&gt; -v &lt;new-name&gt;
   -u or --update &lt;xpath&gt; -v (--value) &lt;value&gt;
                          -x (--expr) &lt;xpath&gt;

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE:</p><pre class="programlisting"># Delete elements matching XPath expression
xml ed -d "/xml/table/rec[@id='2']" xml/table.xml
</pre><p>Input</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre><p>Output</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Move element node
echo '&lt;x id="1"&gt;&lt;a/&gt;&lt;b/&gt;&lt;/x&gt;' | xml ed -m "//b" "//a"
</pre><p>Output</p><pre class="programlisting">&lt;x id="1"&gt;
  &lt;a&gt;
    &lt;b/&gt;
  &lt;/a&gt;
&lt;/x&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Rename attributes
xml ed -r "//*/@id" -v ID xml/tab-obj.xml
</pre><p>Output:</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec ID="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
      &lt;object name="Obj1"&gt;
        &lt;property name="size"&gt;10&lt;/property&gt;
        &lt;property name="type"&gt;Data&lt;/property&gt;
      &lt;/object&gt;
    &lt;/rec&gt;
    &lt;rec ID="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec ID="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Rename elements
xml ed -r "/xml/table/rec" -v record xml/tab-obj.xml
</pre><p>Output:</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;record id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
      &lt;object name="Obj1"&gt;
        &lt;property name="size"&gt;10&lt;/property&gt;
        &lt;property name="type"&gt;Data&lt;/property&gt;
      &lt;/object&gt;
    &lt;/record&gt;
    &lt;record id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/record&gt;
    &lt;record id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/record&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Update value of an attribute
xml ed -u "/xml/table/rec[@id=3]/@id" -v 5 xml/tab-obj.xml
</pre><p>Output:</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;123&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
      &lt;object name="Obj1"&gt;
        &lt;property name="size"&gt;10&lt;/property&gt;
        &lt;property name="type"&gt;Data&lt;/property&gt;
      &lt;/object&gt;
    &lt;/rec&gt;
    &lt;rec id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="5"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Update value of an element
xml ed -u "/xml/table/rec[@id=1]/numField" -v 0 xml/tab-obj.xml
</pre><p>Output:</p><pre class="programlisting">&lt;xml&gt;
  &lt;table&gt;
    &lt;rec id="1"&gt;
      &lt;numField&gt;0&lt;/numField&gt;
      &lt;stringField&gt;String Value&lt;/stringField&gt;
      &lt;object name="Obj1"&gt;
        &lt;property name="size"&gt;10&lt;/property&gt;
        &lt;property name="type"&gt;Data&lt;/property&gt;
      &lt;/object&gt;
    &lt;/rec&gt;
    &lt;rec id="2"&gt;
      &lt;numField&gt;346&lt;/numField&gt;
      &lt;stringField&gt;Text Value&lt;/stringField&gt;
    &lt;/rec&gt;
    &lt;rec id="3"&gt;
      &lt;numField&gt;-23&lt;/numField&gt;
      &lt;stringField&gt;stringValue&lt;/stringField&gt;
    &lt;/rec&gt;
  &lt;/table&gt;
&lt;/xml&gt;
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139576400"></a>4. Validating XML documents</h2></div></div></div><p>Here is synopsis for 'xml val' command:</p><pre class="programlisting">XMLStarlet Toolkit: Validate XML document(s)
Usage: xml val &lt;options&gt; [ &lt;xml-file-or-uri&gt; ... ]
where &lt;options&gt;
   -w or --well-formed        - validate well-formedness only (default)
   -d or --dtd &lt;dtd-file&gt;     - validate against DTD
   -s or --xsd &lt;xsd-file&gt;     - validate against XSD schema
   -r or --relaxng &lt;rng-file&gt; - validate against Relax-NG schema
   -e or --err                - print verbose error messages on stderr
   -b or --list-bad           - list only files which do not validate
   -g or --list-good          - list only files which validate
   -q or --quiet              - do not list files (return result code only)

NOTE: XML Schemas are not fully supported yet due to its incomplete
      support in libxml (see http://xmlsoft.org)

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting"># Validate XML document against DTD
xml val --dtd dtd/table.dtd xml/tab-obj.xml &gt;/dev/null 2&gt;&amp;1; echo $?
</pre><p>Output:</p><pre class="programlisting">1
</pre><p>EXAMPLE</p><pre class="programlisting"># Validate against XSD schema
xml val -b -s xsd/table.xsd xml/table.xml xml/tab-obj.xml 2&gt;/dev/null; echo $?
</pre><p>Output:</p><pre class="programlisting">xml/tab-obj.xml
1
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139569312"></a>5. Formatting XML documents</h2></div></div></div><p>Here is synopsis for 'xml fo' command:</p><pre class="programlisting">XMLStarlet Toolkit: Format XML document
Usage: xml fo [&lt;options&gt;] &lt;xml-file&gt;
where &lt;options&gt; are
   -n or --noindent            - do not indent
   -t or --indent-tab          - indent output with tabulation
   -s or --indent-spaces &lt;num&gt; - indent output with &lt;num&gt; spaces
   -o or --omit-decl           - omit xml declaration &lt;?xml version="1.0"?&gt;
   -R or --recover             - try to recover what is parsable
   -D or --dropdtd             - remove the DOCTYPE of the input docs
   -C or --nocdata             - replace cdata section with text nodes
   -N or --nsclean             - remove redundant namespace declarations
   -e or --encode &lt;encoding&gt;   - output in the given encoding (utf-8, unicode...)
   -H or --html                - input is HTML
   -h or --help                - print help

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting"># Format XML document disabling indent
cat xml/tab-obj.xml | xml fo --noindent 
</pre><p>Output:</p><pre class="programlisting">&lt;xml&gt;
&lt;table&gt;
&lt;rec id="1"&gt;
&lt;numField&gt;123&lt;/numField&gt;
&lt;stringField&gt;String Value&lt;/stringField&gt;
&lt;object name="Obj1"&gt;
&lt;property name="size"&gt;10&lt;/property&gt;
&lt;property name="type"&gt;Data&lt;/property&gt;
&lt;/object&gt;
&lt;/rec&gt;
&lt;rec id="2"&gt;
&lt;numField&gt;346&lt;/numField&gt;
&lt;stringField&gt;Text Value&lt;/stringField&gt;
&lt;/rec&gt;
&lt;rec id="3"&gt;
&lt;numField&gt;-23&lt;/numField&gt;
&lt;stringField&gt;stringValue&lt;/stringField&gt;
&lt;/rec&gt;
&lt;/table&gt;
&lt;/xml&gt;
</pre><p>EXAMPLE</p><pre class="programlisting"># Recover malformed XML document
xml fo -R xml/malformed.xml 2&gt;/dev/null
</pre><p>Input:</p><pre class="programlisting">&lt;test_output&gt;
   &lt;test_name&gt;foo&lt;/testname&gt;
   &lt;subtest&gt;...&lt;/subtest&gt;
&lt;/test_output&gt;
</pre><p>Output:</p><pre class="programlisting">&lt;test_output&gt;
  &lt;test_name&gt;foo&lt;/test_name&gt;
  &lt;subtest&gt;...&lt;/subtest&gt;
&lt;/test_output&gt;
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139560880"></a>6. Canonicalization of XML documents</h2></div></div></div><p>Here is synopsis for 'xml c14n' command:</p><pre class="programlisting">XMLStarlet Toolkit: XML canonicalization
Usage: xml c14n &lt;mode&gt; &lt;xml-file&gt; [&lt;xpath-file&gt;] [&lt;inclusive-ns-list&gt;]
where
  &lt;xml-file&gt;   - input XML document file name (stdin is used if '-')
  &lt;xpath-file&gt; - XML file containing XPath expression for
                 c14n XML canonicalization
    Example:
    &lt;?xml version="1.0"?&gt;
    &lt;XPath xmlns:n0="http://a.example.com" xmlns:n1="http://b.example"&gt;
    (//. | //@* | //namespace::*)[ancestor-or-self::n1:elem1]
    &lt;/XPath&gt;

  &lt;inclusive-ns-list&gt; - the list of inclusive namespace prefixes
                        (only for exclusive canonicalization)
    Example: 'n1 n2'

  &lt;mode&gt; is one of following:
  --with-comments         XML file canonicalization w comments (default)
  --without-comments      XML file canonicalization w/o comments
  --exc-with-comments     Exclusive XML file canonicalization w comments
  --exc-without-comments  Exclusive XML file canonicalization w/o comments

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting"># XML canonicalization
xml c14n --with-comments ../examples/xml/structure.xml ; echo $?
</pre><p>Input ../examples/xml/structure.xml</p><pre class="programlisting">&lt;a1&gt;
  &lt;a11&gt;
    &lt;a111&gt;
      &lt;a1111/&gt;
    &lt;/a111&gt;
    &lt;a112&gt;
      &lt;a1121/&gt;
    &lt;/a112&gt;
  &lt;/a11&gt;
  &lt;a12/&gt;
  &lt;a13&gt;
    &lt;a131/&gt;
  &lt;/a13&gt;
&lt;/a1&gt;</pre><p>Output</p><pre class="programlisting">&lt;a1&gt;
  &lt;a11&gt;
    &lt;a111&gt;
      &lt;a1111&gt;&lt;/a1111&gt;
    &lt;/a111&gt;
    &lt;a112&gt;
      &lt;a1121&gt;&lt;/a1121&gt;
    &lt;/a112&gt;
  &lt;/a11&gt;
  &lt;a12&gt;&lt;/a12&gt;
  &lt;a13&gt;
    &lt;a131&gt;&lt;/a131&gt;
  &lt;/a13&gt;
&lt;/a1&gt;
0
</pre><p>EXAMPLE</p><pre class="programlisting"># XML exclusive canonicalization
xml c14n --exc-with-comments ../examples/xml/c14n.xml ../examples/xml/c14n.xpath
</pre><p>Input</p><pre class="programlisting">../examples/xml/c14n.xml

&lt;n0:pdu xmlns:n0='http://a.example.com'&gt;
&lt;n1:elem1 xmlns:n1='http://b.example'&gt;
content
&lt;/n1:elem1&gt;
&lt;/n0:pdu&gt;

../examples/xml/c14n.xpath

&lt;XPath xmlns:n0="http://a.example.com" xmlns:n1="http://b.example"&gt;
(//. | //@* | //namespace::*)[ancestor-or-self::n1:elem1]
&lt;/XPath&gt;

</pre><p>Output</p><pre class="programlisting">&lt;n1:elem1 xmlns:n1="http://b.example"&gt;
content
&lt;/n1:elem1&gt;
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139550832"></a>7. XML and PYX format</h2></div></div></div><p>Here is synopsis for 'xml pyx' command:</p><pre class="programlisting">XMLStarlet Toolkit: Convert XML into PYX format (based on ESIS - ISO 8879)
Usage: xml pyx {&lt;xml-file&gt;}
where
   &lt;xml-file&gt; - input XML document file name (stdin is used if missing)

The PYX format is a line-oriented representation of
XML documents that is derived from the SGML ESIS format.
(see ESIS - ISO 8879 Element Structure Information Set spec,
ISO/IEC JTC1/SC18/WG8 N931 (ESIS))

A non-validating, ESIS generating tool originally developed for
pyxie project (see http://pyxie.sourceforge.net/)
ESIS Generation by Sean Mc Grath http://www.digitome.com/sean.html

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting">xml pyx input.xml
</pre><p>Input (input.xml)</p><pre class="programlisting">&lt;books&gt;
&lt;book type='hardback'&gt;
&lt;title&gt;Atlas Shrugged&lt;/title&gt;
&lt;author&gt;Ayn Rand&lt;/author&gt;
&lt;isbn id='1'&gt;0525934189&lt;/isbn&gt;
&lt;/book&gt;
&lt;/books&gt;</pre><p>Output</p><pre class="programlisting">(books
-\n
(book
Atype hardback
-\n
(title
-Atlas Shrugged
)title
-\n
(author
-Ayn Rand
)author
-\n
(isbn
Aid 1
-0525934189
)isbn
-\n
)book
-\n
)books</pre><p>PYX is a line oriented format for XML files which can be helpful
      (and very efficient) when used in combination with regular line oriented
      UNIX command such as sed, grep, awk.</p><p>'depyx' option is used for conversion back from PYX into
      XML.</p><p>EXAMPLE (Delete all attributes). This should work really fast for
      very large XML documents.</p><pre class="programlisting">xml pyx input.xml | grep -v  "^A" | xml depyx</pre><p>Output</p><pre class="programlisting">&lt;books&gt;
&lt;book&gt;
&lt;title&gt;Atlas Shrugged&lt;/title&gt;
&lt;author&gt;Ayn Rand&lt;/author&gt;
&lt;isbn&gt;0525934189&lt;/isbn&gt;
&lt;/book&gt;
&lt;/books&gt;</pre><p>Here is an article which describes how PYX format can be used to
      grep XML. <a class="link" href="http://www-106.ibm.com/developerworks/xml/library/x-matters17.html" target="_top">http://www-106.ibm.com/developerworks/xml/library/x-matters17.html</a></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139540960"></a>8. Escape/Unescape special XML characters</h2></div></div></div><p>Here is synopsis for 'xml esc' command:</p><pre class="programlisting">xml esc --help
XMLStarlet Toolkit: Escape special XML characters
Usage: xml esc [&lt;options&gt;] [&lt;string&gt;]
where &lt;options&gt; are
   --help      - print usage
   (TODO: more to be added in future)
if &lt;string&gt; is missing stdin is used instead.

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting"># Escape special XML characters
cat xml/structure.xml | xml esc
</pre><p>Input</p><pre class="programlisting">&lt;a1&gt;
  &lt;a11&gt;
    &lt;a111&gt;
      &lt;a1111/&gt;
    &lt;/a111&gt;
    &lt;a112&gt;
      &lt;a1121/&gt;
    &lt;/a112&gt;
  &lt;/a11&gt;
  &lt;a12/&gt;
  &lt;a13&gt;
    &lt;a131/&gt;
  &lt;/a13&gt;
&lt;/a1&gt;</pre><p>Output</p><pre class="programlisting">&amp;lt;a1&amp;gt;
  &amp;lt;a11&amp;gt;
    &amp;lt;a111&amp;gt;
      &amp;lt;a1111/&amp;gt;
    &amp;lt;/a111&amp;gt;
    &amp;lt;a112&amp;gt;
      &amp;lt;a1121/&amp;gt;
    &amp;lt;/a112&amp;gt;
  &amp;lt;/a11&amp;gt;
  &amp;lt;a12/&amp;gt;
  &amp;lt;a13&amp;gt;
    &amp;lt;a131/&amp;gt;
  &amp;lt;/a13&amp;gt;
&amp;lt;/a1&amp;gt;
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139535968"></a>9. List directory as XML</h2></div></div></div><p>Here is synopsis for 'xml ls' command:</p><pre class="programlisting">XMLStarlet Toolkit: List directory as XML
Usage: xml ls
Lists current directory in XML format.

XMLStarlet is a command line toolkit to query/edit/check/transform
XML documents (for more information see http://xmlstar.sourceforge.net/)
</pre><p>EXAMPLE</p><pre class="programlisting">xml ls
</pre><p>Output</p><pre class="programlisting">&lt;xml&gt;
&lt;d p="rwxrwxrwx" a="20050107T050740Z" m="20050107T050740Z" s="0"  n="old-resume"/&gt;
&lt;f p="rw-rw-rw-" a="20050107T045941Z" m="20050107T045941Z" s="12" n="resume.2old"/&gt;
&lt;f p="rw-rw-rw-" a="20050107T045924Z" m="20050107T045924Z" s="81" n="resume.xml"/&gt;
&lt;/xml&gt;
</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139531936"></a>Chapter 5. Common problems</h1></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139530992"></a>1. Namespaces and default namespace</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm47077139529952"></a>1.1. The Problem: Why does nothing match?</h3></div></div></div><p>You try to extract the links from an XHTML document like
        this:

        </p><pre class="programlisting">xml sel -t -m "//a" -c . -n page.xhtml</pre><p>

        The document contains an <code class="code">&lt;a/&gt;</code> element, but
        there are no matches.

        </p><pre class="programlisting">&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;body&gt;
     &lt;a href="http://example.com"&gt;A link&lt;/a&gt;
&lt;/body&gt;&lt;/html&gt;</pre><p>
        </p><p>
          The problem is the
          <code class="code">xmlns="http://www.w3.org/1999/xhtml"</code> attribute
          on the root element, meaning that it, and all elements below
          have this url as part of their name.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm47077139525808"></a>1.2. The Solution</h3></div></div></div><p>
          To match namespaced elements you must bind the namespace to
          a prefix and prepend it to the name:
          </p><pre class="programlisting">xml sel -N x="http://www.w3.org/1999/xhtml" -t -m "//x:a" -c . -n page.xhtml</pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm47077139523728"></a>1.3. A More Convenient Solution</h3></div></div></div><p>
          XML documents can also use different namespace prefixes, on
          any element in the document. In order to handle namespaces
          with greater ease, XMLStarlet (versions 1.2.1+) will use the
          namespace prefixes declared on the root element of the input
          document. The default namespace will be bound to the
          prefixes "_" and "DEFAULT" (in versions 1.5.0+). So another
          way to solve handle the previous example would be:

          </p><pre class="programlisting">xml sel -t -m "//_:a" -c . -n page.xhtml</pre><p>
        </p><p>
          This feature can be disabled (versions 1.6.0+) by the global
          <code class="code">--no-doc-namespace</code> option. When should you
          disable it? Suppose you are writing a script that handles
          XML documents that look like this:

          </p><pre class="programlisting">&lt;data xmlns:a="http://example.com"&gt;
  &lt;a:important-data&gt;...&lt;/a:important-data&gt;
&lt;/data&gt;
          </pre><p>
          and also this:
          </p><pre class="programlisting">&lt;data xmlns:b="http://example.com"&gt;
  &lt;b:important-data&gt;...&lt;/b:important-data&gt;
&lt;/data&gt;
          </pre><p>
          Since both documents use the same namespace they are
          equivalent, even though the prefixes happen to be different.
          By using <code class="code">--no-doc-namespace</code> and binding the
          namespace with -N, you can be sure that XMLStarlet's
          behaviour will be independant of the input document.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm47077139518336"></a>1.4. Deleting namespace declarations </h3></div></div></div><p>Delete namespace declarations and all elements from non default
        namespace from the following XML document:</p><p>Input (file ns2.xml)</p><pre class="programlisting">&lt;doc xmlns="http://www.a.com/xyz" xmlns:ns="http://www.c.com/xyz"&gt;
  &lt;A&gt;test&lt;/A&gt;
  &lt;B&gt;
    &lt;ns:C&gt;xyz&lt;/ns:C&gt;
  &lt;/B&gt;
&lt;/doc&gt;
        </pre><p>Command:</p><pre class="programlisting">xml ed -N N="http://www.c.com/xyz" -d '//N:*' ns2.xml | \
        sed -e 's/ xmlns.*=".*"//g'</pre><p>Output</p><pre class="programlisting">&lt;doc&gt;
  &lt;A&gt;test&lt;/A&gt;
  &lt;B/&gt;
&lt;/doc&gt;
        </pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139514640"></a>2. Special characters</h2></div></div></div><p>Sometimes issues appear with handling of special characters, where
      'special' means in XML sence as well as in 'shell' terms. Examples below
      should clear at least some of the confusions.</p><p>You should not forget about the fact that your command lines are
      executed by shell and shell does substitutions of its special characters
      too. So for example, one may ask:</p><p>"Why does the following query return nothing?"
      </p><pre class="programlisting">echo '&lt;X name="foo"&gt;EEE&lt;/X&gt;' | xml sel -t -m /X[@name='foo'] -v .</pre><p>The answer lies in the way shell substitues 'foo', which simply
      becomes foo before the command is run. So the correct way to write that
      would be</p><pre class="programlisting">echo '&lt;X name="foo"&gt;EEE&lt;/X&gt;' | xml sel -t -m "/X[@name='foo']" -v .</pre><p>Another example involves XML special characters. Question: How to
      search for &amp;apos; in text nodes?</p><p>The following should help</p><pre class="programlisting">xml sel -t -m "//line[contains(text(),&amp;quot;'&amp;quot;)]" -c .
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139508800"></a>3. Sorting</h2></div></div></div><p>Let's take a look at XSLT produced by the following 'xml sel'
      command:</p><pre class="programlisting"># Query XML document and produce sorted text table
xml sel -T -t -m /xml/table/rec -s D:N:- "@id" \
   -v "concat(@id,'|',numField,'|',stringField)" -n xml/table.xml
</pre><pre class="programlisting">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output omit-xml-declaration="yes" indent="no" method="text"/&gt;
&lt;xsl:param name="inputFile"&gt;-&lt;/xsl:param&gt;
&lt;xsl:template match="/"&gt;
  &lt;xsl:call-template name="t1"/&gt;
&lt;/xsl:template&gt;
&lt;xsl:template name="t1"&gt;
  &lt;xsl:for-each select="/xml/table/rec"&gt;
    &lt;xsl:sort order="descending" data-type="number" 
      case-order="upper-first" select="@id"/&gt;
    &lt;xsl:value-of select="concat(@id,'|',numField,'|',stringField)"/&gt;
    &lt;xsl:value-of select="'&amp;#10;'"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre><p>-s option of 'xml sel' command controls 'order', 'data-type', and
      'case-order' attributes of &lt;xsl:sort/&gt; element .</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm47077139504512"></a>4. Validation</h2></div></div></div><p>Many questions are asked about XSD (XML schema) validation. Well,
      XmlStarlet relies on libxml2 which has incomplete support for XML
      schemas. Untill it is done in libxml2 it will not be in
      XmlStarlet.</p><p></p><p></p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="idm47077139502176"></a>Chapter 6. Other XmlStarlet Resources</h1></div></div></div><p>Here are few articles on the Internet.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://www.freesoftwaremagazine.com/free_issues/issue_06/xml_starlet/" target="_top">XMLStarlet:
        a Unix toolkit for XML</a></p></li><li class="listitem"><p><a class="link" href="http://www-128.ibm.com/developerworks/xml/library/x-starlet.html" target="_top">Start
        working with XMLStarlet</a></p></li><li class="listitem"><p><a class="link" href="http://blogicblog.blogspot.com/2004/09/xmlstarlet-gentle-introduction-into.html" target="_top">XMLStarlet:
        A gentle introduction into XSLT </a></p></li><li class="listitem"><p><a class="link" href="http://blogs.applibase.net/pramod/index.php/archives/command-line-xml-with-xmlstarlet%20" target="_top">Command
        line XML with XMLStarlet </a></p></li><li class="listitem"><p><a class="link" href="http://www.pinkjuice.com/howto/vimxml/moresetup.xml#xmlstarlet" target="_top">Using
        vi as XML editor</a></p></li></ul></div></div></div></body></html>
